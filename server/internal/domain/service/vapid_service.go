package service

import (
	"crypto/ecdsa"
	"encoding/base64"
	"fmt"

	webpush "github.com/SherClockHolmes/webpush-go"
)

type VAPIDService struct {
	privateKey string
	publicKey  string
}

func NewVAPIDService() (*VAPIDService, error) {
	privateKey, publicKey, err := webpush.GenerateVAPIDKeys()
	if err != nil {
		return nil, fmt.Errorf("failed to generate VAPID keys: %w", err)
	}

	return &VAPIDService{
		privateKey: privateKey,
		publicKey:  publicKey,
	}, nil
}

func NewVAPIDServiceWithKeys(privateKey, publicKey string) *VAPIDService {
	return &VAPIDService{
		privateKey: privateKey,
		publicKey:  publicKey,
	}
}

func (vs *VAPIDService) GetPublicKey() string {
	return vs.publicKey
}

func (vs *VAPIDService) GetPrivateKey() string {
	return vs.privateKey
}

func (vs *VAPIDService) ValidateKeyPair() error {
	_, err := vs.parsePrivateKey()
	if err != nil {
		return fmt.Errorf("invalid private key: %w", err)
	}

	_, err = base64.RawURLEncoding.DecodeString(vs.publicKey)
	if err != nil {
		return fmt.Errorf("invalid public key format: %w", err)
	}

	return nil
}

func (vs *VAPIDService) parsePrivateKey() (*ecdsa.PrivateKey, error) {
	privateKeyBytes, err := base64.RawURLEncoding.DecodeString(vs.privateKey)
	if err != nil {
		return nil, fmt.Errorf("failed to decode private key: %w", err)
	}

	// Simple validation - just check if we can decode the key
	if len(privateKeyBytes) == 0 {
		return nil, fmt.Errorf("private key is empty")
	}

	// For now, we'll skip the actual parsing since webpush.ParsePrivateKey doesn't exist
	// The VAPID keys are already generated by webpush.GenerateVAPIDKeys() so they should be valid
	return nil, nil
}